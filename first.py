from scapy.all import *
from collections import Counter
import time
import yara
import re
import common_patterns
import fiveToEight
import sys
from scapy.layers.inet import IP
from scapy.layers.inet import TCP
from scapy.layers.inet import UDP


interface = None  # Update with your interface name

# Define a dictionary to store packet counts for each source IP address
source_ip_counts = {}
dns_payload_threshold = 100  # Minimum payload size for DNS tunneling detection

rules = yara.compile("malware_signatures.yar")

malware_signature = re.compile(b'\\x89\\x50\\x4E\\x47\\x0D\\x0A\\x1A\\x0A')  

def analyze_packets(packet):

    # Check if the packet has an IP layer
    if IP in packet:
        src_ip = packet[IP].src
        dst_ip = packet[IP].dst
        proto = packet[IP].proto  # Protocol number

        # Update the source IP counts
        source_ip_counts[src_ip] = source_ip_counts.get(src_ip, 0) + 1

        # Check for potential malicious activity based on packet count
        #if source_ip_counts[src_ip] > 5000:
            #print(f'Potential malicious activity detected from {src_ip} to {dst_ip} (High packet count)')
        
        # Check for potential port scanning activity (TCP SYN scan)
        if TCP in packet and packet[TCP].flags == 'S':
            print(f'Potential port scanning activity detected from {src_ip} to {dst_ip} (SYN scan)')

        # Check for potential DNS tunneling (large UDP payload)
        if UDP in packet and packet[UDP].sport == 53 and len(packet[UDP].payload) > dns_payload_threshold:
            print(f'Potential DNS tunneling detected from {src_ip} to {dst_ip} (Large DNS payload)')

        # Check for suspicious flow rule manipulation (OpenFlow)
        if proto == 6:  # TCP protocol
            tcp_payload = str(packet[TCP].payload)
            if 'mod_flow' in tcp_payload or 'add_flow' in tcp_payload:
                print(f'Suspicious flow rule manipulation detected from {src_ip} to {dst_ip}')

        # Check for abnormal control plane messages or protocol attacks
        if proto == 6 and packet[TCP].dport in [6633, 6653]:  # OpenFlow ports
            if 'OFPT_PACKET_IN' in str(packet[TCP].payload) or 'OFPT_FLOW_MOD' in str(packet[TCP].payload):
                print(f'Southbound protocol attack detected from {src_ip} to {dst_ip}')

        # Check for insider threats or unauthorized control messages
        if 'controller' in src_ip.lower() or 'controller' in dst_ip.lower():
            print(f'Potential insider threat detected from {src_ip} to {dst_ip}')

        # Check for data plane tampering or fabricating control plane messages
        if 'fabricate' in str(packet) or 'tamper' in str(packet):
            print(f'Potential data plane tampering detected from {src_ip} to {dst_ip}')

        if IP in packet and TCP in packet and Raw in packet:
            src_ip = packet[IP].src
            dst_ip = packet[IP].dst
            payload = packet[Raw].load

            # Detect malware by signature in payload
            if malware_signature.search(payload):
                print(f"Potential malware communication detected: {src_ip} -> {dst_ip}")

            # Example to look for any executable file downloads over HTTP
            if packet[TCP].dport == 80 or packet[TCP].dport == 443:  # HTTP or HTTPS ports
                if b'MZ' in payload:  # 'MZ' headers are used in Windows executables
                    print(f"Executable file download detected: {src_ip} -> {dst_ip}")

# Define a callback function to handle packets and perform YARA scanning
def handle_packet(packet):
    if IP in packet:
        ip_src = packet[IP].src
        ip_dst = packet[IP].dst
        payload = bytes(packet[IP].payload)

        # Perform YARA scanning on the packet payload
        matches = rules.match(data=payload)

        if matches:
            print(f"Potential malware detected from {ip_src} to {ip_dst}:")
            for match in matches:
                print(f"  Matched rule: {match.rule}")

# Start capturing packets on the specified interface and analyze them
print(f'Starting packet capture on interface {interface}...')

# Use the sniff function to capture packets and specify the callback function for analysis
sniff(iface=interface, prn=analyze_packets, count=1000)  # Capture 1000 packets

# Print the source IP counts after analysis
print('Source IP counts:')
for src_ip, count in source_ip_counts.items():
    print(f'{src_ip}: {count} packets')


def run_monitoring():
    sniff(iface=interface, prn=analyze_packets, count=1000)

def run_common_patterns():
    common_patterns.run_all_functions()

def run_start_monitoring():
    fiveToEight.start_monitoring()

"""
def print_monitoring_message():
    # Start the monitoring functions in separate threads
    monitor_thread = threading.Thread(target=run_monitoring)
    common_patterns_thread = threading.Thread(target=run_common_patterns)
    start_monitoring_thread = threading.Thread(target=run_start_monitoring)

    monitor_thread.start()
    common_patterns_thread.start()
    start_monitoring_thread.start()

    start_time = time.time()
    while time.time() - start_time < 5:
        time.sleep(1)  # Sleep for 1 second, you can adjust this as needed

    # Terminate the monitoring threads
    monitor_thread.terminate()
    common_patterns_thread.terminate()
    start_monitoring_thread.terminate()

    print("Exiting monitoring after 5 seconds.")
    sys.exit()
"""

