from scapy.all import *
import threading
import time
from scapy.layers.inet import IP
from scapy.layers.inet import TCP
from scapy.layers.inet import UDP
import yara
import re
import base64

# Global list to store detected threats
detected_threats = []

rules = yara.compile("malware_signatures.yar")

dns_payload_threshold = 50  # Minimum payload size for DNS tunneling detection
malware_signature = re.compile(b'\\x89\\x50\\x4E\\x47\\x0D\\x0A\\x1A\\x0A')
pdf_signature = re.compile(rb'%PDF.*%%EOF', re.DOTALL)  # Matches PDF files
office_signature = re.compile(rb'(PK\x03\x04|D0CF11E0A1B11AE1)', re.DOTALL)  # Matches Office documents

sql_injection_patterns = [
    re.compile(rb';--'),   # SQL comment injection
    re.compile(rb' OR 1=1'),  # Simple SQL injection payload
    # Add more patterns as needed
]


dns_queries = defaultdict(int)
query_times = defaultdict(lambda: datetime.now())

# Parameters for detection
EXCESSIVE_LIMIT = 50  # Threshold for excessive DNS queries per minute
LONG_SUBDOMAIN_THRESHOLD = 10  # Length threshold for what constitutes a long subdomain

executable_header = re.compile(b'MZ')
script_shebang = re.compile(b'#!/bin/bash')

obfuscated_js_pattern = re.compile(rb"\W(eval|function|var)\W.*\W(window|document|eval|function|var)\W", re.I)
base64_pattern = re.compile(rb'(?:(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?)')

DATA_VOLUME_THRESHOLD = 5000000  # Adjust according to your network (in bytes)
COMMON_PORTS = [80, 443]  # Commonly used ports

data_volumes = defaultdict(int)
port_activity = defaultdict(int)



def detection(packet):

    src_ip = packet[IP].src
    dst_ip = packet[IP].dst
    proto = packet[IP].proto  # Protocol number
    threat_description = ""

    if IP in packet and TCP in packet and Raw in packet:
        src_ip = packet[IP].src
        dst_ip = packet[IP].dst
        payload = packet[Raw].load

        # Example to look for any executable file downloads over HTTP
        if packet[TCP].dport == 80 or packet[TCP].dport == 443:  # HTTP or HTTPS ports
            if b'MZ' in payload:  # 'MZ' headers are used in Windows executables
                threat_description = f"Executable file download detected: {src_ip} -> {dst_ip}"


    if UDP in packet:
        # Check for suspicious DNS queries
        if packet[UDP].dport == 53 and Raw in packet and b"suspicious_domain" in packet[Raw].load:
            threat_description = f"Suspicious DNS query detected from {src_ip} to {dst_ip}"

        # Check for potential DNS tunneling
        if packet[UDP].sport == 53 and len(packet[UDP].payload) > dns_payload_threshold:
            threat_description = f'Potential DNS tunneling detected from {src_ip} to {dst_ip} (Large DNS payload)'

    if IP in packet:
        src_ip = packet[IP].src
        dst_ip = packet[IP].dst        
        proto = packet[IP].proto  # Protocol number


        #if packet[TCP].dport == 443:
        #    threat_description = f"Executable file download detected: {src_ip} -> {dst_ip}"
        
        if UDP in packet and packet[UDP].sport == 53 and len(packet[UDP].payload) > dns_payload_threshold:
            threat_description = f'Potential DNS tunneling detected from {src_ip} to {dst_ip} (Large DNS payload)'

        if TCP in packet and packet[TCP].flags == 'S':
            threat_description = f'Potential port scanning activity detected from {src_ip} to {dst_ip} (SYN scan)'

        if UDP in packet and packet[UDP].sport == 53 and len(packet[UDP].payload) > dns_payload_threshold:
            threat_description = f'Potential DNS tunneling detected from {src_ip} to {dst_ip} (Large DNS payload)'
        


    if(threat_description != ""):
        detected_threats.append(threat_description)
        print(threat_description)

    return detected_threats

# Define a callback function for sniffing that uses the detection function
def packet_callback(packet):
    detection(packet)

# Function to stop sniffing after a timeout
def stop_sniffing(sniffer):
        if sniffer.running:
            print("Stopping sniffing...")
            sniffer.stop()
        else:
            print("Sniffer was already stopped.")

# Main function to run the script
def detect_potential_threats(timeout=3):
    global detected_threats
    detected_threats = []  # Reset the list of detected threats

    interface = None

    # Start sniffing in a separate thread using async_sniff
    sniffer = AsyncSniffer(iface=interface, prn=packet_callback, count=1000)
    sniffer.start()

    # Create a timer to stop sniffing after the specified timeout
    timer = threading.Timer(10, stop_sniffing, [sniffer])
    timer.start()

    # Wait for the sniffer thread to finish
    sniffer.join()
    return detected_threats
