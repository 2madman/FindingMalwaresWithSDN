from scapy.all import sniff, IP, TCP, UDP, Raw
from collections import defaultdict
import threading
import re

DATA_VOLUME_THRESHOLD = 5000000  # Adjust according to your network (in bytes)
COMMON_PORTS = [80, 443]  # Commonly used ports
UNUSUAL_PORTS = set(range(1024, 65535))  # Ports that are not commonly used for services

data_volumes = defaultdict(int)
port_activity = defaultdict(int)

pdf_signature = re.compile(rb'%PDF.*%%EOF', re.DOTALL)  # Matches PDF files
office_signature = re.compile(rb'(PK\x03\x04|D0CF11E0A1B11AE1)', re.DOTALL)  # Matches Office documents

sql_injection_patterns = [
    re.compile(rb';--'),   # SQL comment injection
    re.compile(rb' OR 1=1'),  # Simple SQL injection payload
    # Add more patterns as needed
]

malicious_hex_patterns = [
    re.compile(rb'90909090'),  # NOP sleds (e.g., 0x90 0x90 0x90 0x90)
    re.compile(rb'EBFE'),  # Short jump instruction (e.g., 0xEB 0xFE)
    re.compile(rb'31C0B002'),  # XOR EAX, EAX; MOV AL, 0x2 (common in shellcode)
    re.compile(rb'FFD7'),  # Call EDI (common in shellcode)
    re.compile(rb'CCAABBCC'),  # Example of another hex pattern
    # Add more patterns as needed
]

def print_monitoring_message():
    while True:
        print("Monitoring network traffic...")
        threading.Event().wait(3)
        exit()

def traffic_analysis(packet):
    if IP in packet:
        src_ip = packet[IP].src
        dst_ip = packet[IP].dst
        packet_length = len(packet)

        # Aggregate data transferred per IP
        data_volumes[src_ip] += packet_length

        if TCP in packet or UDP in packet:
            src_port = packet[TCP].sport if TCP in packet else packet[UDP].sport
            dst_port = packet[TCP].dport if TCP in packet else packet[UDP].dport

            if src_port in UNUSUAL_PORTS or dst_port in UNUSUAL_PORTS:
                port_activity[(src_ip, dst_port)] += 1

            if src_port in COMMON_PORTS or dst_port in COMMON_PORTS:
                port_activity[(src_ip, dst_port)] += 1

        if data_volumes[src_ip] > DATA_VOLUME_THRESHOLD:
            print(f"High data transfer volume detected from {src_ip}: {data_volumes[src_ip]} bytes")

        for (ip, port), count in port_activity.items():
            if count > 1000: 
                print(f"Unusual port usage detected: IP {ip} on port {port} has been used {count} times")
            
def http_packet_analysis(packet):
    if TCP in packet and Raw in packet:
        payload = packet[Raw].load

        # Check if the payload is HTTP (starts with "GET", "POST", etc.)
        if payload.startswith(b'GET') or payload.startswith(b'POST') or payload.startswith(b'PUT'):
            # Check for SQL injection patterns in URI or POST data
            for pattern in sql_injection_patterns:
                if pattern.search(payload):
                    print(f"Potential SQL injection detected in HTTP traffic from {packet[IP].src}: {pattern.pattern}")


def hex_pattern_analysis(packet):
    if IP in packet and TCP in packet and Raw in packet:
        payload = packet[Raw].load

        # Check if the payload contains hexadecimal content
        hex_payload = bytes.fromhex(payload.decode('utf-8', errors='ignore'))

        # Search for common malicious hex patterns
        for pattern in malicious_hex_patterns:
            if pattern.search(hex_payload):
                print(f"Potential malicious hex pattern detected in network traffic from {packet[IP].src}: {pattern.pattern}")

def file_signature_analysis(packet):
    if IP in packet and TCP in packet and Raw in packet:
        payload = packet[Raw].load

        # Check if payload matches PDF or Office document signatures
        if pdf_signature.search(payload):
            print(f"Potential PDF file detected in network traffic from {packet[IP].src}")

        if office_signature.search(payload):
            print(f"Potential Office document detected in network traffic from {packet[IP].src}")

def start_monitoring():
    monitoring_thread = threading.Thread(target=print_monitoring_message)
    monitoring_thread.daemon = True
    monitoring_thread.start()

    print("Starting traffic monitoring...")
    traffic_thread = threading.Thread(target=lambda: sniff(prn=traffic_analysis, store=False))
    traffic_thread.start()

    print("Starting HTTP traffic monitoring for SQL injection indicators...")
    http_thread = threading.Thread(target=lambda: sniff(filter="tcp port 80", prn=http_packet_analysis, store=False))
    http_thread.start()

    print("Starting network traffic monitoring for common malicious hex patterns...")
    hex_thread = threading.Thread(target=lambda: sniff(prn=hex_pattern_analysis, store=False))
    hex_thread.start()

    print("Starting network traffic monitoring for file headers and footers...")
    file_thread = threading.Thread(target=lambda: sniff(prn=file_signature_analysis, store=False))
    file_thread.start()



